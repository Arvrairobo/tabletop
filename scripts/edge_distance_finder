#! /usr/bin/env python

from __future__ import print_function
import sys
import threading
from math import cos, tan, atan2, pi
import cv2
import numpy as np
import rospy
from rospy.numpy_msg import numpy_msg
from sensor_msgs.msg import CompressedImage, LaserScan

class Position:
    def __init__(self):
        self.angle = None
        self.x = None
        self.min_y = None
        self.slope = None

class EdgeDistanceFinder:

    def __init__(self):
        self.thread_lock = threading.Lock()

    def run(self):
        rospy.init_node('calibrate_distance')

        self.scan_pub = rospy.Publisher('scan', numpy_msg(LaserScan),
                                        queue_size=1)

        rospy.Subscriber('image/compressed', numpy_msg(CompressedImage),
                         self.on_image)
        rospy.spin()

    def on_image(self, msg):
        data = np.fromstring(msg.data, np.uint8)
        frame = cv2.imdecode(data, cv2.IMREAD_COLOR)
        thread = threading.Thread(target=self.process_image,
                                  args=(msg.header, frame))
        thread.setDaemon(True)
        thread.start()

    def process_image(self, header, frame):
        # Skip this image if we're already processing an image.
        # That is, if we cannot acquire the thread lock with no
        # delay, then another thread has the lock and is processing
        # an image. This reduces our effective frame rate to what
        # we can process.
        if not self.thread_lock.acquire(False):
            rospy.loginfo('Skipping frame because other thread busy')
            return

        try:
            rospy.loginfo('Got frame with data size {0}'.format(frame.shape))

            im_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            med = np.median(im_gray)
            lower = int(max(0, (1 - 0.5)*med))
            upper = int(min(255, (1 + 0.5)*med))
            edges = cv2.Canny(im_gray, lower, upper)
            kernel = np.ones((3,3), np.uint8)
            edges = cv2.dilate(edges, kernel, iterations=1)

            lines = cv2.HoughLinesP(edges, 1, 1*np.pi/180, 50, minLineLength=75, maxLineGap=10)

            vert_fov = 43.5 # 41.1 according to the spec
            horz_fov = 53.5*pi/180
            angles = [angle*pi/180 for angle in range(-24, 24, 3)]
            horz_fd = frame.shape[1]/2 / tan(horz_fov/2)
            vert_fd = frame.shape[0]/2 / tan(vert_fov/2)
            vert_refdist = 0.4
            camera_height = 0.13
            vert_refang = atan2(vert_refdist, camera_height)

            positions = []
            for angle in angles:
                pos = Position()
                pos.angle = angle
                pos.x = frame.shape[1]/2 - int(round(horz_fd*tan(angle)))
                pos.max_y = None
                pos.distance = 10.0
                pos.slope = None
                positions.append(pos)

            margin = 3
            for line in lines:
                x0, y0, x1, y1 = line[0]
                if x0 >= frame.shape[1]-margin and x1 >= frame.shape[1]-margin \
                   or y0 >= frame.shape[0]-margin and y1 >= frame.shape[0]-margin:
                    continue
            
                # Make sure line goes to the right.
                if x0 > x1:
                    x0,x1 = x1,x0
                    y0,y1 = y1,y0

                for pos in positions:
                    if x0 < pos.x and x1 >= pos.x:
                        slope = float(y1 - y0) / (x1 - x0)
                        y = int(round(y0 + slope*(pos.x - x0)))
                        if (pos.max_y is None) or y > pos.max_y:
                            pos.max_y = y
                            pos.slope = -slope
                            pos.distance \
                                = self.get_distance(frame.shape[1]/2 - pos.x,
                                                    frame.shape[0]/2 - y,
                                                    camera_height,
                                                    horz_fd,
                                                    vert_refang, vert_fd)

            scan = LaserScan()
            scan.header.stamp = rospy.Time.now()
            scan.header.frame_id = header.frame_id
            scan.angle_min = angles[0]
            scan.angle_max = angles[-1]
            scan.angle_increment = angles[1] - angles[0]
            scan.time_increment = 0
            scan.scan_time = 0
            scan.range_min = 0
            scan.range_max = 2.0
            scan.ranges = [pos.distance for pos in positions]
            self.scan_pub.publish(scan)

        finally:
            self.thread_lock.release()

    def get_distance(self, dx, dy, camera_height, horz_fd, vert_refang, vert_fd):
        horz_angle = abs(atan2(dx, horz_fd))
        vert_angle = vert_refang - atan2(dy, vert_fd)
        dist_ahead = camera_height * tan(vert_angle)
        return dist_ahead / cos(horz_angle)

if __name__ == "__main__":
    try:
        EdgeDistanceFinder().run()

    except rospy.ROSInterruptException:
        pass
