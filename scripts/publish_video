#! /usr/bin/env python

from __future__ import print_function
import sys
import picamera
import picamera.array
import cv2
import numpy as np
import rospy
from rospy.numpy_msg import numpy_msg
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image
from tabletop.msg import MotionVector
from tabletop.msg import MotionVectorArray

class FrameAnalyzer(picamera.array.PiRGBAnalysis):

    def __init__(self, camera, pub, frame_id, size):
        super(FrameAnalyzer, self).__init__(camera, size)
        self.pub = pub
        self.frame_id = frame_id
        self.bridge = CvBridge()

    def analyze(self, frame):
        now = rospy.Time.now()
        rospy.loginfo('Analyzing frame, size=%s', frame.shape)

        msg = self.bridge.cv2_to_imgmsg(frame, 'bgr8')
        msg.header.stamp = now
        msg.header.frame_id = self.frame_id
        self.pub.publish(msg)

class MotionAnalyzer(picamera.array.PiMotionAnalysis):

    def __init__(self, camera, pub, size):
        super(MotionAnalyzer, self).__init__(camera)
        self.pub = pub
        self.size = size

    def analyze(self, vectors):
        now = rospy.Time.now()
        rospy.loginfo('Analyzing vectors')

        h, w = vectors.shape
        vectors = vectors.reshape(h*w)

        motion_vectors = []
        for vec in vectors:
            mvec = MotionVector()
            mvec.x = vec['x']
            mvec.y = vec['y']
            mvec.sad = vec['sad']
            motion_vectors.append(mvec)

        msg = MotionVectorArray()
        msg.header.stamp = now
        msg.image_width = self.size[0]
        msg.image_height = self.size[1]
        msg.width = w
        msg.height = h
        msg.vectors = motion_vectors
        self.pub.publish(msg) 
        rospy.loginfo('Finished analyzing vectors')

class VideoPublisher:

    def __init__(self):
        pass

    def run(self):
        rospy.init_node('publish_video')

        frame_rate = rospy.get_param('~frame_rate', 10)
        image_width = rospy.get_param('~image_width', 640)
        image_height = rospy.get_param('~image_height', 480)
        vector_width = rospy.get_param('~vector_width', 640)
        vector_height = rospy.get_param('~vector_height', 480)
        frame_id = rospy.get_param('~frame_id', 'camera_link')

        image_pub = rospy.Publisher('image', Image, queue_size=10)
        vector_pub = rospy.Publisher('motion_vectors',
                                     numpy_msg(MotionVectorArray),
                                     queue_size=10)

        with picamera.PiCamera() as camera:
            image_size = (image_width, image_height)
            vector_size = (vector_width, vector_height)
            camera.resolution = vector_size
            camera.framerate = frame_rate

            with FrameAnalyzer(camera, image_pub, frame_id, image_size) \
                 as frame_analyzer:
                with MotionAnalyzer(camera, vector_pub, vector_size) \
                     as motion_analyzer:
                    camera.start_recording('/dev/null', 'h264',
                        intra_period=0, motion_output=motion_analyzer)
                    camera.start_recording(frame_analyzer, 'bgr',
                        splitter_port=2, resize=image_size)
                    try:
                        while not rospy.is_shutdown():
                            camera.wait_recording(1)
                    except:
                        print('Unexpected error: {0}'.format(sys.exc_info()[0]))
                        raise
                    finally:
                        camera.stop_recording(splitter_port=2)
                        camera.stop_recording()

if __name__ == "__main__":
    try:
        VideoPublisher().run()

    except rospy.ROSInterruptException:
        pass
